/*
 * Falcon version 0.0.2 (master, Dec 02 2019)
 * fl-object.h: Falcon's object representation
 * See Falcon's license in the LICENSE file
 */

#ifndef FALCON_OBJECT_H
#define FALCON_OBJECT_H

#include "fl-bcode.h"
#include "fl-value.h"
#include <stddef.h>

/* Types of objects on Falcon */
typedef enum {
    OBJ_STRING,   /* A string literal */
    OBJ_FUNCTION, /* A declared function */
    OBJ_UPVALUE,  /* A upvalue captured by a closure */
    OBJ_CLOSURE,  /* A representation of a first-class function */
    OBJ_CLASS,    /* A declared class */
    OBJ_INSTANCE, /* A instance of a class */
    OBJ_BMETHOD,  /* A method bound to a receiver */
    OBJ_LIST,     /* A list literal */
    OBJ_MAP,      /* A map literal */
    OBJ_NATIVE    /* A native function implementation */
} ObjType;

/* Defines the built-in objects representation. It holds a flag to know if the object was marked by
 * the garbage collector, the object's type, and a pointer to the list of all currently allocated
 * objects in the virtual machine */
struct _Obj {
    bool isMarked;
    ObjType type;
    struct _Obj *next;
};

/* A string object. It holds the length (not including \0), the hash (see "falcon_string.h"), and
 * the array of characters that compose the string */
struct _ObjString {
    FalconObj obj;
    size_t length;
    uint32_t hash;
    char chars[]; /* Flexible array member */
};

/* A key-value entry of an ObjMap. Keys must be ObjStrings and values can be any FalconValue. A
 * entry with key equals to NULL is empty */
typedef struct {
    ObjString *key;
    FalconValue value;
} MapEntry;

/* A map object. It implements a hashtable of MapEntries, mapping a key to a value.
 * The hashtable uses open addressing with linear probing, and the hashtable itself is a dynamic
 * array of MapEntries.
 * When a entry is removed from the entries array, the entry is actually marked as a tombstone
 * (i.e., a special sentinel that marks a deleted entry in a probe sequence). Tombstones are
 * represented as key equals to NULL and value equals to "true" */
typedef struct {
    FalconObj obj;
    int count;
    int capacity;
    MapEntry *entries;
} ObjMap;

/* A function object. It holds the bytecode chuck (the instructions generated by the compiler for
 * this function) and other information, like its arity and the number of upvalues. A function is
 * always wrapped inside a ObjClosure, even if there are no upvalues, to simplify the way the
 * virtual machine execute them */
typedef struct {
    FalconObj obj;
    int arity;
    int upvalueCount;
    BytecodeChunk bytecode;
    ObjString *name;
} ObjFunction;

/* A upvalue object. It represents a local variable that has been used by a closure. A upvalue can
 * be open or closed. A open upvalue points to a stack slot, since the local is still in the scope
 * where it was declared. A upvalue becomes closed when the local goes out of scope. In that case,
 * the stack slot is copied to the upvalue.
 * A upvalue object holds the stack slot that it references, the closed slot if the local goes out
 * of scope, and a pointer to the next upvalue in the list stored on the virtual machine */
typedef struct _ObjUpvalue {
    FalconObj obj;
    FalconValue *slot;
    FalconValue closed;
    struct _ObjUpvalue *next;
} ObjUpvalue;

/* A closure object. It represents a first-class function. Moreover, it holds the function that
 * this closure implements and the list of upvalues that it closes over */
typedef struct {
    FalconObj obj;
    ObjFunction *function;
    ObjUpvalue **upvalues;
    int upvalueCount;
} ObjClosure;

/* A class object. It holds the name of the class and a map of methods the class declares */
typedef struct {
    FalconObj obj;
    ObjString *name;
    ObjMap methods;
} ObjClass;

/* A class instance object. It holds its related class and a map of fields that the instance
 * owns */
typedef struct {
    FalconObj obj;
    ObjClass *class_;
    ObjMap fields;
} ObjInstance;

/* A bound method object. It holds the receiver the method should be bound to and the closure that
 * implements the method */
typedef struct {
    FalconObj obj;
    FalconValue receiver;
    ObjClosure *method;
} ObjBMethod;

/* A list object. It holds a dynamic array of FalconValues */
typedef struct {
    FalconObj obj;
    ValueArray elements;
} ObjList;

/* Native functions signature */
typedef FalconValue (*FalconNativeFn)(FalconVM *vm, int argCount, FalconValue *args);

/* A native function object. It holds an implementation of a FalconNativeFn (see signature above)
 * and its name */
typedef struct {
    FalconObj obj;
    FalconNativeFn function;
    const char *name;
} ObjNative;

/* Extracts the type of an FalconObj from a given FalconValue */
#define OBJ_TYPE(value) (AS_OBJ(value)->type)

/* Checks if the type of a FalconValue is a given ObjType. It returns a boolean value, indicating
 * whether the value is of the macro type */
#define IS_STRING(value)   isObjType(value, OBJ_STRING)
#define IS_CLASS(value)    isObjType(value, OBJ_CLASS)
#define IS_INSTANCE(value) isObjType(value, OBJ_INSTANCE)
#define IS_LIST(value)     isObjType(value, OBJ_LIST)
#define IS_MAP(value)      isObjType(value, OBJ_MAP)

/* Casts a FalconValue to a specific ObjType. No validation is performed, so C errors will likely
 * rise if the value type was not tested previously (see the macros above) */
#define AS_STRING(value)   ((ObjString *) AS_OBJ(value))
#define AS_CSTRING(value)  (((ObjString *) AS_OBJ(value))->chars)
#define AS_FUNCTION(value) ((ObjFunction *) AS_OBJ(value))
#define AS_CLOSURE(value)  ((ObjClosure *) AS_OBJ(value))
#define AS_CLASS(value)    ((ObjClass *) AS_OBJ(value))
#define AS_INSTANCE(value) ((ObjInstance *) AS_OBJ(value))
#define AS_BMETHOD(value)  ((ObjBMethod *) AS_OBJ(value))
#define AS_LIST(value)     ((ObjList *) AS_OBJ(value))
#define AS_MAP(value)      ((ObjMap *) AS_OBJ(value))
#define AS_NATIVE(value)   ((ObjNative *) AS_OBJ(value))

/* Returns the name, as a string, of a given ObjType */
const char *get_object_name(ObjType type);

/* Creates a new empty ObjString of a given length by claiming ownership of the new string */
ObjString *make_string(FalconVM *vm, size_t length);

/* Copies and allocates a given string, of a given length, to the heap */
ObjString *new_ObjString(FalconVM *vm, const char *chars, size_t length);

/* Allocates a new ObjFunction and initializes its fields */
ObjFunction *new_ObjFunction(FalconVM *vm);

/* Allocates a new ObjUpvalue and initializes its fields, setting the upvalue slot to a given
 * FalconValue */
ObjUpvalue *new_ObjUpvalue(FalconVM *vm, FalconValue *slot);

/* Allocates a new ObjClosure and initializes its fields, also allocating a list of ObjUpvalues and
 * setting the closure function to a given ObjFunction */
ObjClosure *new_ObjClosure(FalconVM *vm, ObjFunction *function);

/* Allocates a new ObjClass and initializes its fields, setting its name to a given ObjString */
ObjClass *new_ObjClass(FalconVM *vm, ObjString *name);

/* Allocates a new ObjInstance and initializes its fields, setting its class to a given ObjClass */
ObjInstance *new_ObjInstance(FalconVM *vm, ObjClass *class_);

/* Allocates a new ObjBMethod and initializes its fields, setting its receiver to a given
 * FalconValue and its method to a given ObjClosure */
ObjBMethod *new_ObjBMethod(FalconVM *vm, FalconValue receiver, ObjClosure *method);

/* Allocates a new ObjList and initializes its fields, also allocating a list of FalconValues of a
 * given size */
ObjList *new_ObjList(FalconVM *vm, uint16_t size);

/* Allocates a new empty ObjMap and initializes its fields */
ObjMap *new_ObjMap(FalconVM *vm);

/* Allocates a new ObjNative and initializes its fields, setting its function to a given
 * FalconNativeFn and its name to a given string */
ObjNative *new_ObjNative(FalconVM *vm, FalconNativeFn function, const char *name);

/**
 * Checks if a given FalconValue is of a given ObjType.
 */
static inline bool isObjType(FalconValue value, ObjType type) {
    return IS_OBJ(value) && AS_OBJ(value)->type == type;
}

#endif // FALCON_OBJECT_H
